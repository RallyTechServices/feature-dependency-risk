<!DOCTYPE html>
<html>

<head>
    <title>CATS-
        Feature Dependency Risk-
            0.0.1
    </title>
    <!--  (c) 2017 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Mon Apr 30 2018 17:08:23 GMT+0000 (UTC) -->

    <script type="text/javascript">
        var APP_BUILD_DATE = "Mon Apr 30 2018 17:08:23 GMT+0000 (UTC)";
        var ARTIFACT = "";
        var BUILDER = "ec2-user";
        var CHECKSUM = "7301100965";
    </script>

    <script type="text/javascript" src="https://us1.rallydev.com/apps/2.1/sdk-debug.js"></script>
    <!-- our highcharts (needed so that we can add patterns)
    <script type="text/javascript" src="/apps/2.1/lib/analytics/analytics-all.js"></script>
    -->


    <script type="text/javascript">
        Rally.onReady(function() {
             
/* global Ext */
Ext.define('Constants', function(Constants) {
    return {
        statics: {
            PORTFOLIO_ITEM_FETCH_FIELDS: ['Predecessors', 'Successors'],
            CLASS: {
                STATUS_COLOR_PREFIX: 'status-color',
                STATUS_COLORS: 'status-colors'
            }
        }
    }
});

/* global Ext Rally _ */

/*
    Without these overrides columns are Stripped by Rally.ui.grid.GridColumnCfgTransformer if dataIndex of column is not in the model
    model comes from the store model (see _buildColumns). The tree store builder creates a composite
    model for portfolio items that include all possible child types (stories, tasks, defects, etc),
    however _decorateModels override doesn't decorate the composite model, only the sub-model.
    Alternatively, GridColumnCfgTransformer.transform should check models.getArtifactComponentModels when
    determining invalid fields. Need to check the tree store sort to see which model it sorts (the composite,
    or each individual...)
    
    Sort is based on column.getSortParam() which calls store.sort(). Store.model is the composite `Artifact`
    model.
    
    Options:
    * doSort includes a `fn` in the config to store.sort() to allow a per-column sort function, or pass a
    function instead of a config (see decodeSorters)
    * consider model.field.sortType
    * listen to 'beforesort'
    * get the extra fields into the composite model
    
    _removeSortableFromUnsortableColumns (my new column.sortable=undefined), is true by end of _augmentColumnConfigs
*/

Ext.override(Rally.data.wsapi.TreeStore, {
    _decorateModels: function() {
        var models = this.model;

        // Must add it to composite model otherwise any column with a dataIndex will be excluded
        this.addExtraFields(models);

        if (_.isFunction(models.getArtifactComponentModels)) {
            models = models.getArtifactComponentModels();
        }

        Ext.Array.each(models, function(m) {
            if (m.typePath.indexOf("portfolioitem/") != -1) {
                this.addExtraFields(m)
            }
        }, this);
        _.each(Ext.Array.from(models), Rally.ui.grid.data.NodeInterface.decorate, Rally.ui.grid.data.NodeInterface);
    },

    addExtraFields: function(model) {
        model.addField({
            name: 'PredecessorsStoryCountColorSortKey',
            type: 'string',
            defaultValue: '',
            modelType: model.typePath, // TODO (tj) modelType used anywhere?
            getUUID: function() { // Must include a getUUID function for state save/restore to work
                return this.name;
            }
        });
        model.addField({
            name: 'PredecessorsPlanEstimateColorSortKey',
            type: 'string',
            defaultValue: '',
            modelType: model.typePath,
            getUUID: function() {
                return this.name;
            }
        });
        model.addField({
            name: 'SuccessorsStoryCountColorSortKey',
            type: 'string',
            defaultValue: '',
            modelType: model.typePath,
            getUUID: function() {
                return this.name;
            }
        });
        model.addField({
            name: 'SuccessorsPlanEstimateColorSortKey',
            type: 'string',
            defaultValue: '',
            modelType: model.typePath,
            getUUID: function() {
                return this.name;
            }
        });
    }
});

Ext.override(Rally.ui.grid.TreeGrid, {
    _mergeColumnConfigs: function(newColumns, oldColumns) {

        var mergedColumns = _.map(newColumns, function(newColumn) {
            var oldColumn = _.find(oldColumns, { dataIndex: this._getColumnName(newColumn) });
            if (oldColumn) {
                return this._getColumnConfigFromColumn(oldColumn);
            }

            return newColumn;
        }, this);
        if (this.config && this.config.derivedColumns) {
            mergedColumns = mergedColumns.concat(this.config.derivedColumns);
        }
        return mergedColumns;
    },
    _restoreColumnOrder: function(columnConfigs) {

        var currentColumns = this._getColumnConfigsBasedOnCurrentOrder(columnConfigs);
        var addedColumns = _.filter(columnConfigs, function(config) {
            return !_.find(currentColumns, { dataIndex: config.dataIndex }) || Ext.isString(config);
        });

        return currentColumns.concat(addedColumns);
    },
    _applyStatefulColumns: function(columns) {
        // TODO (tj) test default columns
        if (this.alwaysShowDefaultColumns) {
            _.each(this.columnCfgs, function(columnCfg) {
                if (!_.any(columns, { dataIndex: this._getColumnName(columnCfg) })) {
                    columns.push(columnCfg);
                }
            }, this);
        }

        if (this.config && this.config.derivedColumns) {
            // Merge the derived column config with the stateful column if the dataIndex is the same,
            // Otherwise add the derived columns if they aren't present.
            //this.columnCfgs = columns.concat(this.config.derivedColumns);
            _.each(this.config.derivedColumns, function(derivedColumnCfg) {
                var columnState = _.find(columns, { dataIndex: this._getColumnName(derivedColumnCfg) });
                if (columnState) {
                    // merge them (add renderer)
                    _.merge(columnState, derivedColumnCfg);
                }
                else {
                    // insert the derived column at the end
                    columns.push(derivedColumnCfg);
                }
            }, this);
        }

        this.columnCfgs = columns;
    },
    /*
    // derived columns likely don't use Rally.data.wsapi.Field, and don't have getUUID.
    // This override tests for getUUID function BEFORE calling it
    _getPersistableColumnConfig: function(column) {
        var columnConfig = this._getColumnConfigFromColumn(column),
            field = this._getModelField(columnConfig.dataIndex);
        if (field && field.getUUID) {
            columnConfig.dataIndex = field.getUUID();
        }
        return columnConfig;
    },
    */
});

/* global Ext _ Rally */
Ext.define('MetricsManager', function(MetricsManager) {
    return {
        statics: {
            addMetrics: addMetrics,
            STATUS_LABEL_ORDER: [{
                    label: 'Late',
                    hex: '#F66349',
                    count: 0
                },
                {
                    label: 'At Risk',
                    hex: '#FAD200',
                    count: 0
                },
                {
                    label: 'Not Started',
                    hex: '#E0E0E0',
                    count: 0
                },
                {
                    label: 'On Track',
                    hex: '#8DC63F',
                    count: 0
                },
                {
                    label: 'Complete',
                    hex: '#D1D1D1',
                    count: 0
                }
            ]
        }
    }

    function addMetrics(records) {
        _.forEach(records, function(record) {
            if (record.get('_type') != 'portfolioitem/feature') {
                return
            }

            var predecessorsRef = record.get('Predecessors');
            var successorsRef = record.get('Successors');
            if (predecessorsRef.Count > 0) {
                record
                    .getCollection('Predecessors')
                    .load()
                    .then(function(predecessors) {
                        record.set('PredecessorCount', predecessors.length);
                        var storyCountColors = {};
                        var planEstimateColors = {};
                        _.forEach(predecessors, function(item) {
                            var color;
                            color = Ext.Object.merge({}, Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(item.data, 'PercentDoneByStoryCount'));
                            var colorKey = color.label;
                            if (!storyCountColors[color.label]) {
                                color.count = 1;
                                // Must use merge because HealthColorCalculator returns status objects
                                storyCountColors[color.label] = Ext.Object.merge({}, color);
                            }
                            else {
                                storyCountColors[color.label].count += 1;
                            }

                            color = Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(item.data, 'PercentDoneByStoryPlanEstimate');
                            colorKey = color.label;
                            if (!planEstimateColors[color.label]) {
                                color.count = 1;
                                planEstimateColors[color.label] = Ext.Object.merge({}, color);
                            }
                            else {
                                planEstimateColors[color.label].count += 1;
                            }
                        });
                        splitColors(record, storyCountColors, 'Predecessors', 'StoryCount');
                        splitColors(record, planEstimateColors, 'Predecessors', 'PlanEstimate');
                    });
            }

            if (successorsRef.Count > 0) {
                record
                    .getCollection('Successors')
                    .load()
                    .then(function(successors) {
                        record.set('SuccessorCount', successors.length);
                        var storyCountColors = {};
                        var planEstimateColors = {};
                        _.forEach(successors, function(item) {
                            var color;
                            color = Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(item.data, 'PercentDoneByStoryCount');
                            var colorKey = color.label;
                            if (!storyCountColors[colorKey]) {
                                color.count = 1;
                                storyCountColors[colorKey] = Ext.Object.merge({}, color);
                            }
                            else {
                                storyCountColors[colorKey].count += 1;
                            }

                            color = Rally.util.HealthColorCalculator.calculateHealthColorForPortfolioItemData(item.data, 'PercentDoneByStoryPlanEstimate');
                            colorKey = color.label;
                            if (!planEstimateColors[colorKey]) {
                                color.count = 1;
                                planEstimateColors[colorKey] = Ext.Object.merge({}, color);
                            }
                            else {
                                planEstimateColors[colorKey].count += 1;
                            }
                        });
                        splitColors(record, storyCountColors, 'Successors', 'StoryCount');
                        splitColors(record, planEstimateColors, 'Successors', 'PlanEstimate');
                    });
            }
        });
    }

    function splitColors(record, colors, relation, metric) {
        var sortedColors = [];
        _.forEach(MetricsManager.STATUS_LABEL_ORDER, function(statusLabel) {
            sortedColors.push(colors[statusLabel.label] ? colors[statusLabel.label] : statusLabel);
        });
        record.set(relation + metric + 'Colors', sortedColors);
        record.set(relation + metric + 'ColorSortKey', _.pluck(sortedColors, 'count').join('+'));
    }
});

/* global Ext MetricsManager Constants Rally _ */
Ext.define("CArABU.app.TSApp", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    defaults: { margin: 10 },
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    integrationHeaders: {
        name: "CArABU.app.TSApp"
    },

    launch: function() {
        var modelNames = ['portfolioitem/feature'];
        var context = this.getContext();

        Ext.create('Rally.data.wsapi.TreeStoreBuilder').build({
            models: modelNames,
            autoLoad: false,
            enableHierarchy: true,
            listeners: {
                scope: this,
                load: function(store, node, records) {
                    MetricsManager.addMetrics(records);
                }
            },
            fetch: Constants.PORTFOLIO_ITEM_FETCH_FIELDS
        }).then({
            success: function(store) {
                this.add({
                    xtype: 'rallygridboard',
                    context: this.getContext(),
                    modelNames: modelNames,
                    toggleState: 'grid',
                    plugins: [{
                            ptype: 'rallygridboardinlinefiltercontrol',
                            inlineFilterButtonConfig: {
                                stateful: true,
                                stateId: context.getScopedStateId('feature-filters'),
                                modelNames: modelNames,
                                inlineFilterPanelConfig: {
                                    quickFilterPanelConfig: {
                                        defaultFields: [
                                            'ArtifactSearch',
                                            'Owner',
                                            'State'
                                        ]
                                    }
                                }
                            }
                        },
                        {
                            ptype: 'rallygridboardfieldpicker',
                            headerPosition: 'left',
                            modelNames: modelNames,
                            stateful: true,
                            stateId: context.getScopedStateId('feature-columns')
                        }
                    ],
                    gridConfig: {
                        store: store,
                        enabledEditing: true,
                        shouldShowRowActionsColumn: true,
                        enableRanking: false,
                        enableBulkEdit: false,
                        alwaysShowDefaultColumns: false, // Otherwise you get 2 copies of the `derived` columns
                        stateful: true,
                        stateId: context.getScopedStateId('grid-state'),
                        listeners: {
                            scope: this,
                            cellclick: function(grid, td, cellIndex, record, tr, rowIndex, event) {
                                // If this is a status color cell, show the dependencies popover
                                if (Ext.query('.' + Constants.CLASS.STATUS_COLORS, td).length > 0) {
                                    var popover = Rally.ui.popover.PopoverFactory.bake({
                                        field: 'PredecessorsAndSuccessors',
                                        record: record,
                                        target: td
                                    });
                                }
                            }
                        },
                        columnCfgs: this.getColumns(),
                        derivedColumns: this.getDerivedColumns()
                    },
                    height: this.getHeight()
                });
            },
            scope: this
        });
    },

    getColumns: function() {
        // TODO (tj) are derived columns needed in getColumns...or perhaps override can detect
        // a derived column in the normal column list
        return [
            'Name',
        ].concat(this.getDerivedColumns());
    },
    getDerivedColumns: function() {
        return [{
                dataIndex: 'PredecessorsStoryCountColorSortKey',
                text: 'Predecessors By Story Count',
                //width: 100,
                //tpl: '<span><tpl for="PredecessorsStoryCountColors"><span class="{[ values.label.toLowerCase().replace(" ","-") ]}">{count}</span></tpl></span>',
                scope: this,
                renderer: function(value, meta, record, row, col, store) {
                    return this.colorsRenderer(record.get('PredecessorsStoryCountColors'));
                }
            },
            {
                dataIndex: 'PredecessorsPlanEstimateColorSortKey',
                text: 'Predecessors By Plan Estimate',
                scope: this,
                //width: 100,
                renderer: function(value, meta, record, row, col, store) {
                    return this.colorsRenderer(record.get('PredecessorsPlanEstimateColors'));
                }
            },
            {
                dataIndex: 'SuccessorsStoryCountColorSortKey',
                text: 'Successors By Story Count',
                scope: this,
                //width: 100,
                renderer: function(value, meta, record, row, col, store) {
                    return this.colorsRenderer(record.get('SuccessorsStoryCountColors'));
                }
            },
            {
                dataIndex: 'SuccessorsPlanEstimateColorSortKey',
                text: 'Successors By Plan Estimate',
                scope: this,
                //width: 100,
                renderer: function(value, meta, record, row, col, store) {
                    return this.colorsRenderer(record.get('SuccessorsPlanEstimateColors'));
                }
            }
        ];
    },
    colorsRenderer: function(sortedColors) {
        //return '<span><tpl for="SuccessorsPlanEstimateColors"><span class="{[ values.label.toLowerCase().replace(" ","-") ]}">{count}</span></tpl></span>';
        var nonZeroColors = _.filter(sortedColors,
            function(color) {
                return color.count > 0;
            });
        var result = _.map(nonZeroColors, function(color) {
            var colorClass = color.label.toLowerCase().replace(" ", "-");
            return '<div class="' + Constants.CLASS.STATUS_COLOR_PREFIX + ' ' + colorClass + '">' + color.count + '</div>'
        });
        return '<div class="' + Constants.CLASS.STATUS_COLORS + '">' + result.join('') + '</div>'
    }
});


            Rally.launchApp('CArABU.app.TSApp', {
                name: 'Feature Dependency Risk'
            });
        });
    </script>

    <style type="text/css">
        
.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.status-colors {
    display:inline-flex;
}

.status-color {
    padding: 0 5px 0 5px;
    border-radius: 50px;
}

.late {
    background-color: #F66349;
}

.at-risk {
    background-color: #FAD200;
}

.not-started {
    background-color: #E0E0E0;
}

.on-track {
    background-color: #8DC63F;
}

.complete {
    background-color: #D1D1D1;
}
    </style>

</head>

<body></body>

</html>